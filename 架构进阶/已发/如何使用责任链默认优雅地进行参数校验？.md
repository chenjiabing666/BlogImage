**大家好，我是不才陈某~**

项目中参数校验十分重要，它可以保护我们应用程序的安全性和合法性。我想大家通常的做法是像下面这样做的:

```java
@Override
public void validate(SignUpCommand command) {
    validateCommand(command); // will throw an exception if command is not valid
    validateUsername(command.getUsername()); // will throw an exception if username is duplicated
    validateEmail(commend.getEmail()); // will throw an exception if email is duplicated
}
```

这么做最大的优势就是简单直接，但是如果验证逻辑很复杂，会导致这个类变得很庞大，而且上面是通过抛出异常来改变代码执行流程，这也是一种不推荐的做法。

那么有什么更好的参数校验的方式呢？本文就推荐一种通过责任链设计模式来优雅地实现参数的校验功能，我们通过一个用户注册的例子来讲明白如何实现。

- 有效的注册数据——名字、姓氏、电子邮件、用户名和密码。
- 用户名必须是唯一的。
- 电子邮件必须是唯一的。

## **定义用户注册和验证结果类**

1. 定义一个`SignUpCommand`类用来接受用户注册的属性信息。并且使用 `@Value` 注解让这个类不可变。

```java
import lombok.Value;

import javax.validation.constraints.*;

@Value
public class SignUpCommand {

    @Min(2)
    @Max(40)
    @NotBlank
    private final String firstName;

    @Min(2)
    @Max(40)
    @NotBlank
    private final String lastName;

    @Min(2)
    @Max(40)
    @NotBlank
    private final String username;

    @NotBlank
    @Size(max = 60)
    @Email
    private final String email;

    @NotBlank
    @Size(min = 6, max = 20)
    private final String rawPassword;
```

- 使用`javax.validation`中的注解如`@NotBlank`、`@Size`来验证用户注册信息是否有效。
- 使用`lombok`的注解`@Value`，因为我希望命令对象是不可变的。注册用户的数据应与注册表中填写的数据相同。

1. 定义存储验证结果类`ValidationResult`，如下所示：

```java
@Value
public class ValidationResult {
    private final boolean isValid;
    private final String errorMsg;

    public static ValidationResult valid() {
        return new ValidationResult(true, null);
    }

    public static ValidationResult invalid(String errorMsg) {
        return new ValidationResult(false, errorMsg);
    }

    public boolean notValid() {
        return !isValid;
    }
}
```

- 在我看来，这是一种非常方便的方法返回类型，并且比抛出带有验证消息的异常要好。

1. 既然是责任链，还需要定义一个“链”类`ValidationStep`，它是这些验证步骤的超类，我们希望将它们相互“链接”起来。

```java
public abstract class ValidationStep<T> {

    private ValidationStep<T> next;

    public ValidationStep<T> linkWith(ValidationStep<T> next) {
        if (this.next == null) {
            this.next = next;
            return this;
        }
        ValidationStep<T> lastStep = this.next;
        while (lastStep.next != null) {
            lastStep = lastStep.next;
        }
        lastStep.next = next;
        return this;
    }

    public abstract ValidationResult validate(T toValidate);

    protected ValidationResult checkNext(T toValidate) {
        if (next == null) {
            return ValidationResult.valid();
        }

        return next.validate(toValidate);
    }
}
```

## **核心验证逻辑**

现在我们开始进行参数校验的核心逻辑，也就是如何把上面定义的类给串联起来。

1. 我们定义一个用于注册验证的接口类`SignUpValidationService`

```java
public interface SignUpValidationService {
    ValidationResult validate(SignUpCommand command);
}
```

1. 现在我们可以使用上面定义的类和责任链模式来轻松的实现，代码如下：

```java
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import java.util.Set;

@Service
@AllArgsConstructor
public class DefaultSignUpValidationService implements SignUpValidationService {

    private final UserRepository userRepository;

    @Override
    public ValidationResult validate(SignUpCommand command) {
        return new CommandConstraintsValidationStep()
                .linkWith(new UsernameDuplicationValidationStep(userRepository))
                .linkWith(new EmailDuplicationValidationStep(userRepository))
                .validate(command);
    }

    private static class CommandConstraintsValidationStep extends ValidationStep<SignUpCommand> {

        @Override
        public ValidationResult validate(SignUpCommand command) {
            try (ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory()) {
                final Validator validator = validatorFactory.getValidator();
                final Set<ConstraintViolation<SignUpCommand>> constraintsViolations = validator.validate(command);

                if (!constraintsViolations.isEmpty()) {
                    return ValidationResult.invalid(constraintsViolations.iterator().next().getMessage());
                }
            }
            return checkNext(command);
        }
    }

    @AllArgsConstructor
    private static class UsernameDuplicationValidationStep extends ValidationStep<SignUpCommand> {

        private final UserRepository userRepository;

        @Override
        public ValidationResult validate(SignUpCommand command) {
            if (userRepository.findByUsername(command.getUsername()).isPresent()) {
                return ValidationResult.invalid(String.format("Username [%s] is already taken", command.getUsername()));
            }
            return checkNext(command);
        }
    }

    @AllArgsConstructor
    private static class EmailDuplicationValidationStep extends ValidationStep<SignUpCommand> {

        private final UserRepository userRepository;

        @Override
        public ValidationResult validate(SignUpCommand command) {
            if (userRepository.findByEmail(command.getEmail()).isPresent()) {
                return ValidationResult.invalid(String.format("Email [%s] is already taken", command.getEmail()));
            }
            return checkNext(command);
        }
    }
}
```

- `validate`方法是核心方法，其中调用`linkWith`方法组装参数的链式校验器，其中涉及多个验证类，先做基础验证，如果通过的话，去验证用户名是否重复，如果也通过的话，去验证`Email`是否重复。
- `CommandConstraintsValidationStep`类，此步骤是一个基础验证，所有的`javax validation annotation`都会被验证，比如是否为空，`Email`格式是否正确等等。这非常方便，我们不必自己编写这些验证器。如果一个对象是有效的，那么调用`checkNext`方法让流程进入下一步，`checkNext`，如果不是，`ValidationResult` 将立即返回。
- `UsernameDuplicationValidationStep`类，此步骤验证用户名是否重复，主要需要去查数据库了。如果是，那么将立即返回无效的`ValidationResult`，否则的话继续往后走，去验证下一步。
- `EmailDuplicationValidationStep` 类，电子邮件重复验证。因为没有下一步，如果电子邮件是唯一的，则将返回`ValidationResult.valid()`。

## **总结**

上面就是通过责任链模式来实现我们参数校验的完整过程了，你学会了吗?这种方式可以优雅的将验证逻辑拆分到单独的类中，如果添加新的验证逻辑，只需要添加新的类，然后组装到“校验链”中。但是在我看来，这比较适合于用于校验相对复杂的场景，如果只是简单的校验就完全没必要这么做了，反而会增加代码的复杂度。

## 最后说一句（别白嫖，求关注）

陈某每一篇文章都是精心输出，如果这篇文章对你有所帮助，或者有所启发的话，帮忙**点赞**、**在看**、**转发**、**收藏**，你的支持就是我坚持下去的最大动力！

另外陈某的[知识星球](https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247523057&idx=1&sn=32b42c6b0ac41b48785b7c0d24ce344a&chksm=fcf7453ccb80cc2a4a6cf38d5b9ab0354f09f270418bf4ff5eeb832b020aedabd561979b712d&token=1260267649&lang=zh_CN#rd)开通了，公众号回复关键词：**知识星球** 获取限量**30元**优惠券加入只需**89**元，一顿饭钱，但是星球回馈的价值却是巨大，目前更新了**Spring全家桶实战系列**、**亿级数据分库分表实战**、**DDD微服务实战专栏**、**我要进大厂、Spring，Mybatis等框架源码、架构实战22讲**等....每增加一个专栏价格将上涨20元

![](https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rBvqdy8J18dlib7KepGcvuW08g7COtYpQvVoZzRtQFLgaW1GxibV1vsWMQ27S4wsOlt1ySoh3uEAeIw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

关注公众号：【码猿技术专栏】，公众号内有超赞的粉丝福利，回复：加群，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！