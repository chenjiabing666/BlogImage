**大家好，我是不才陈某~**

业务场景：服务A对接了服务B，服务C等服务的一些接口，然后由服务A统一暴露接口给到外部用户使用。

其中有个需求是：服务A可以动态的接入服务B/C的接口，对外暴露，并无需重启服务Ａ，即支持API接口的动态添加。

这篇文章就来聊聊具体的业务如何实现？

## **思路方案**

### 传统的API接口暴露方法

传统的业务开发，使用 springboot 的话，会把服务需要暴露的 API 接口写在 controller 层里，然后调用 service 层的接口方法，在实现层 implement 该 service 接口方法的具体实现函数。

- controller层

```java
@RestController
@RequestMapping({"/v1"})
@Slf4j
public class HelloController {

    @Autowired
    private HelloService helloService;

    @PostMapping(path = {"/hello"})
    public String hello() {
        return Optional.ofNullable(helloService.hello())
                .map(ret -> new ResponseEntity<>(ret, HttpStatus.OK))
                .orElseThrow(() -> new MMException("something wrong"));
    }
}


```

- service层

```java
public interface HelloService {
    String hello();
}

```

- 实现层

```java
@Service
public class HelloServiceImpl implements HelloService {


    @Override
    public String hello(){
        return "hello world";
    }
}

```

我们可以看到，在 controller 层 API 接口的 subpath 是写好的，构建部署之后，服务具有的 API 接口列表就固定了。如果需要新增 API 接口，就需要重新在 controller 里写代码，编译构建，再部署上线。这样效率很低，而且每次部署，都会影响到线上服务，也不安全。

### 泛化的方法

**对于 OpenAPI 的业务场景来说，其实是不关心接入的 API subpath 具体是什么，只关心能不能通过 subpath 找到对应的需要转发的服务。**

那么，在 controller 层，就可以不根据具体的 subpath 来匹配对应的服务，而是通过请求的方法**get、post、put**　+　**通配符**的方式来分类接收外部请求，然后利用 AOP切面 和 Threadlocal 来处理和传递 subpath 携带的信息，给到实现层，最终在实现层分发请求到各个业务服务的 API 接口。

## **具体实施**

### **OpenAPI 的 URL 规范**

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3d4faa939394890803fd4ca17f55ed4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?) 

分为几个组成部分：

1. **http method**： 请求方法，get、post、put、delete等
2. **http scheme**： http or https
3. **OpenAPI统一域名**： 外部访问 OpenAPI 的统一域名
4. **资源访问类型**： 访问的资源，api、web等
5. **OpenAPI版本号**： OpenAPI 服务自身的版本号
6. **内部服务的名称**： OpenAPI 对接的内部服务名称（标识）
7. **内部服务的path**： 对接内部服务API的 subpath

### **代码实现**

**泛化的 controller 层实现** 以Get、Post请求为例：

```java
@RestController
@RequestMapping({"/v1"})
@Slf4j
@ServicePath
public class OpenApiController {

    @Autowired
    private OpenApiService openApiService;

    @ApiOperation("OpenAPI POST接收")
    @PostMapping(path = {"/**"})
    public ResponseEntity<ReturnBase> filterPost(@Validated @RequestBody(required = false) Map<String, Object> reqMap) {
        return Optional.ofNullable(openApiService.filter(reqMap, null))
                .map(ret -> new ResponseEntity<>(ret, HttpStatus.OK))
                .orElseThrow(() -> new MMException("error.openapi.filter", ReturnEnum.C_GENERAL_BUSINESS_ERROR.getMsgCode()));
    }


    @ApiOperation("OpenAPI GET接收")
    @GetMapping(path = {"/**"})
    public ResponseEntity<ReturnBase> filterGet(@RequestParam(required = false) MultiValueMap<String, String> params) {
        return Optional.ofNullable(openApiService.filter(null, params))
                .map(ret -> new ResponseEntity<>(ret, HttpStatus.OK))
                .orElseThrow(() -> new MMException("error.openapi.filter", ReturnEnum.C_GENERAL_BUSINESS_ERROR.getMsgCode()));
    }
}

```

**service层和service实现层**

```java
public interface OpenApiService {
    ReturnBase filter(Map<String, Object> reqBodyMap, MultiValueMap<String, String> reqGetParamsMap);
}

@Service
@Slf4j
public class OpenApiServiceImpl implements OpenApiService {

    @Override
    public ReturnBase filter(Map<String, Object> reqBodyMap, MultiValueMap<String, String> reqGetParamsMap) {
        String svcName = (String) OpenapiThreadlocal.getServiceParams().get(BizConstant.SVC_NAME);
        String svcPathPublic = (String) OpenapiThreadlocal.getServiceParams().get(BizConstant.SVC_PATH_PUBLIC);
       
        return doBizHandler(svcName, svcPathPublic);
    }
}

```

**AOP切面和注解**

```java
@Aspect
@Component
@Slf4j
@Order(1)
public class ServicePathAspect {
    static final Pattern PATTERN = Pattern.compile("/v\\d+(/.+)");

    @Resource
    private CustomProperty customProperty;

    @Pointcut("@within(org.xxx.annotation.ServicePath)")
    public void servicePathOnClass() {}

    @Pointcut("@annotation(org.xxx.annotation.ServicePath)")
    public void servicePathOnMethod() {
    }

    @Before(value = "servicePathOnClass() || servicePathOnMethod()")
    public void before() {
        HttpServletRequest hsr = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        String reqUri = hsr.getRequestURI();
        String httpMethod = hsr.getMethod();
        if (StrUtil.isEmpty(reqUri)) {
            log.error("request uri is empty");
            throw new MMException(ReturnEnum.A_PARAM_VALIDATION_ERROR);
        }
        Matcher matcher = PATTERN.matcher(reqUri);
        String servicePath = "";
        while (matcher.find()) {
            servicePath = matcher.group(1);
        }
        if (StrUtil.isEmpty(servicePath)) {
            log.error("can't parse service path from {}", reqUri);
            throw new MMException(ReturnEnum.A_PARAM_VALIDATION_ERROR);
        }
        String[] split = servicePath.split("\\/");
        if (split.length < 3) {
            log.error("api format error: {}", servicePath);
            throw new MMException(ReturnEnum.A_PARAM_VALIDATION_ERROR);
        }
        String serviceName = split[1];
        servicePath = servicePath.substring(serviceName.length() + 1);

        Map<String, Object> map = Maps.newHashMap();
        map.put(BizConstant.SVC_NAME, serviceName);
        map.put(BizConstant.SVC_PATH_PUBLIC, servicePath);
        map.put(BizConstant.START_TIMESTAMP, start);
        OpenapiThreadlocal.addServiceParams(map);
    }
}

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ServicePath {
}

```

**Threadlocal工具**

```java
public class OpenapiThreadlocal {

    private final static ThreadLocal<Map<String,Object>> SERVICE_PARAMS_HOLDER = new ThreadLocal<>();

    public static void addServiceParams(Map<String, Object> svcParamsMap) {
        SERVICE_PARAMS_HOLDER.set(svcParamsMap);
    }

    public static Map<String, Object> getServiceParams() {
        return SERVICE_PARAMS_HOLDER.get();
    }

    public static void removeServiceParams() {
        SERVICE_PARAMS_HOLDER.remove();
    }

}

```

至此，**服务A可以动态的接入服务B/C的接口，对外暴露，并无需重启服务Ａ，即支持API接口的动态添加**的业务需求实现完毕。

来源：https://juejin.cn/post/7195811094333276220

## 最后说一句（别白嫖，求关注）

陈某每一篇文章都是精心输出，如果这篇文章对你有所帮助，或者有所启发的话，帮忙**点赞**、**在看**、**转发**、**收藏**，你的支持就是我坚持下去的最大动力！

另外陈某的[知识星球](https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247523057&idx=1&sn=32b42c6b0ac41b48785b7c0d24ce344a&chksm=fcf7453ccb80cc2a4a6cf38d5b9ab0354f09f270418bf4ff5eeb832b020aedabd561979b712d&token=1260267649&lang=zh_CN#rd)开通了，公众号回复关键词：**知识星球** 获取限量**30元**优惠券加入只需**89**元，一顿饭钱，但是星球回馈的价值却是巨大，目前更新了**Spring全家桶实战系列**、**亿级数据分库分表实战**、**DDD微服务实战专栏**、**我要进大厂、Spring，Mybatis等框架源码、架构实战22讲**等....每增加一个专栏价格将上涨20元

![](https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rBvqdy8J18dlib7KepGcvuW08g7COtYpQvVoZzRtQFLgaW1GxibV1vsWMQ27S4wsOlt1ySoh3uEAeIw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

关注公众号：【码猿技术专栏】，公众号内有超赞的粉丝福利，回复：加群，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！